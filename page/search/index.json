[{"content":"Slides TL;DW The point of my talk is that all the best practices that apply under normal circumstances are doubly necessary under difficult circumstances, such as building for bad internet, old phones, small screens, or technically inexperienced users.\nThere is no shortcut to learning best practices, but here are some good sources for further reading.\nBad Internet Box If you want to get your own Bad Internet Box, I suggest you contact PJH Technologies.\nGoogle Tips I feel that this Google Architecture Recommendation Guide is right now the best starting point for building the architecture that allows you to more easily adapt for low connectivity and old phones.\nOnce you have the basic architecture set up, the Google Build for Billions Guide and the Google Performance Guidelines both have a myriad of great tips.\nThis recent article by Ben Weiss, as well as this series of articles by Niharika Arora on optimizing for Android Go, are both good supplements to the above.\nOther Reading The Http client standard is hosted here, with a direct link to how they define idempotent methods.\nThis medium article has a good warning about how OkHttp default retry works.\nVideo This video explains the complex logic behind offline-first apps, in an extremely simple and straightforward way. I consider offline first architecture to be the most important first step towards supporting low connectivity environments. However, it is part of a larger series of videos on modern android development which I also recommend.\nAlso This video helped me a lot to build the skills to understand and implement a lot of the above, and I just like recommending it because it\u0026rsquo;s a timeless and important presentation.\n","date":"2022-11-21T00:00:00Z","image":"https://jacquessmuts.github.io/images/bad_internet_header.png","permalink":"https://jacquessmuts.github.io/post/2022/bad-internet/","title":"Further Reading for Bad Internet, Old Phones"},{"content":"Using named arguments in Kotlin causes breaking changes to be caught faster. This article shows you how.\nThis article is a follow-up on Part 1 in this series, wherein I explain why the test pyramid is incomplete, and that you should architect so that breaking changes gets caught at compile-time if possible.\nFurther context: I wrote this in 2020, but crashed out from pandemic-induced stress before I could finish the series. I\u0026rsquo;m now going back to finish it.\nWhat is a named argument? When you pass an argument to a function or parameter, you can name the argument instead of just passing in the arguments in the right order. This is most powerful when you have optional arguments, but for now, let\u0026rsquo;s assume you have a simple User class.\nfun main() {\r//sampleStart\rdata class User(\rval name: String,\rval surname: String,\rval age: Int = 0\r)\r// This is how you would normally pass arguments. Name, Surname, Age.\rval userNormal = User(\r\u0026#34;Kim\u0026#34;,\r\u0026#34;Katsuragi\u0026#34;,\r43\r)\r// This is how you use named arguments. You put in extra effort to specifically name the arguments you are passing in.\rval userNamed = User(\rname = \u0026#34;Klaasje\u0026#34;,\rsurname = \u0026#34;Amandou\u0026#34;,\rage = 28\r)\r//sampleEnd\rprintln(\u0026#34;$userNormal is literally the best.\u0026#34;)\r}\rWhy is a named argument? Named arguments are usually used to differentiate between several optional parameters and pass in only the necessary arguments. That is a great use of them, however I contend that you should almost always use named arguments. Especially if you have more than two arguments.\nThe reason for this can be demonstrated simply. What if a developer was tasked to add a height field? It\u0026rsquo;d be very easy to make this mistake:\nfun main() {\r//sampleStart\r// Added `height`\rdata class User(\rval name: String,\rval surname: String,\rval height: Int, // height added here.\rval age: Int? = null\r)\rval userNormal = User(\r\u0026#34;Kim\u0026#34;,\r\u0026#34;Katsuragi\u0026#34;,\r43\r)\rval userNamed = User(\rname = \u0026#34;Klaasje\u0026#34;,\rsurname = \u0026#34;Amandou\u0026#34;,\rage = 28\r)\r//sampleEnd\rprintln(\u0026#34;$userNamed is an extremely well written character. I refused to arrest her, despite knowing that she\u0026#39;s manipulative.\u0026#34;)\r}\rIf you run the above code, you\u0026rsquo;ll get a compiler error. Note that the error appears (correctly) for the userNamed variable, but not for userNormal. Now Kim Katsuragi has a height of 43 and an age of null.\nThis might seem like a contrived example, because \u0026ldquo;everybody knows that you should put new variables at the end\u0026rdquo;. I disagree with that notion, because it places the burden of knowledge on future unknown developers or circumstances. It\u0026rsquo;s often that developers feel the need to change the order of arguments or variables. They usually don\u0026rsquo;t, for fear of breaking things. However if you always use named arguments, the order of constructor inputs would not be a factor, and refactoring your constructor would carry less risk.\nI\u0026rsquo;ve run into various scenarios where I\u0026rsquo;ve had to change the arguments on a function/constructer where I had to manually go through every single instance where the function was called to make sure it was still being called correctly despite the change. Furthermore, I don\u0026rsquo;t know what unit-test can be written to ensure that all instances of a constructor is being called correctly. However when I switched to named arguments, I knew that the calling code would always keep working if no change was required, and throw a compiler error if a change was required.\nNamed arguments catches breaking changes from incorrect arguments immediately, in a way which would be slower with unit-tests.\nHowever this only works if you use named arguments everywhere. It\u0026rsquo;s not forced.\nNamed Arguments Sounds Great. Can I Force Their Use (a little bit)? Some people would propose this hacky workaround that is as clever as it is unpleasant to implement. Don\u0026rsquo;t do this.\nOr you can add a lint check to your project which forces you to use named arguments.\nI tried to write this little library which does it for you. It forces all functions or constructors with more than two arguments to require named arguments, otherwise it tags it as an error. Unfortunately, this library doesn\u0026rsquo;t work reliably. I kept struggling with lint, and eventually gave up (see context at the start of this article).\nHowever, you can see there is some demand for it in Kotlin itself, here, as well as in Detekt. You can use this library to force any one function to have NamedArguments, but you can\u0026rsquo;t enforce it project-wide with specific rulesets easily.\nRegardless of lint libraries, you should use this IntelliJ plugin to easily fill arguments or add names to arguments. I use it all of the time.\nConclusion Use named arguments. Not everywhere all the time, but use them regularly.\n","date":"2022-11-07T11:33:09+02:00","image":"https://jacquessmuts.github.io/images/compile_test_named_arg.png","permalink":"https://jacquessmuts.github.io/post/compile_time_tests2/","title":"Use More Named Arguments in Kotlin"},{"content":"Kotlin allows us to structure our code around compile-time tests. This post explains how.\nFour layered testing pyramid You probably know the testing pyramid. Unit tests run faster and are easier to develop and run, so you should have more of them, compared to your integration tests and end-to-end tests. However if you assume that this pyramid applies to any sort of automated validation of your code, then the testing pyramid should actually look like this:\nTesting Pyramid\u0026#43; If you\u0026rsquo;re wondering what Compile Time tests mean, I mean everything that runs during and even before compilation, to provide \u0026ldquo;Compile Time Safety\u0026rdquo;: Static Analysis, Syntax Errors, Linting, Generated Classes, (Gradle) Build Tool Tasks and anything else I might be forgetting. Compile time tests refers to any errors you get that prevent your unit-tests from running in the first place.\nI\u0026rsquo;m sure I\u0026rsquo;m not the first one to propose this. I looked around and found a few other similar ideas, but only really in the JavaScript community. My guess is that since they cannot rely on the compiler by default, they consider the addition of static tests to be part of the testing framework. Java/Kotlin developers, on the other hand, consider type safety to be an assumed but separate step from the testing framework.\nFail Fast Verification Leaving the pyramid aside, I knew that the concept had to be much older than 2016. I did some research and found this amazing paper by Margaret Hamilton. If you don\u0026rsquo;t know Margaret Hamilton, all you have to know is that she\u0026rsquo;s able to ship bug-free code, like some kind of mad scientist. You need to read the full article, but for our purposes I\u0026rsquo;ll sum up the relevant parts. Her proposal is that a software system should be verified in this order:\nConceptually Statically Dynamically The static verification at the time was extremely limited, so they had to build a lot of it themselves. Margaret Hamilton took \u0026ldquo;fail fast\u0026rdquo; to its logical conclusion and did everything in her power to pick up problems before they became problems; first in planning, then in code. She also designed and implemented end-to-end testing systems, but preferred to have the majority of the validation be done before the end-to-end tests ran. Furthermore, her analyses concluded that bugs are less likely to occur if you have modular systems, as well as extensive documentation, specifications and conceptual planning in place before coding starts.\nSo with that background in place, let\u0026rsquo;s get back to the four-layered testing pyramid.\nFour layered testing pyramid, in Kotlin Testing Pyramid\u0026#43; You should be aware that there are some variations to and criticism of the original testing pyramid, but that it makes a good rule of thumb for architecting your processes and systems. When you search for blogs or literature about how the testing pyramid fits into software development, you will find little-to-zero mention of static analysis or compiler checks. Yet if you\u0026rsquo;re coding in Java/Kotlin your IDE is constantly running automated checks on your code that most people consider to be completely separate from their automated tests. It is important to consider compile-time tests as just one part of a bigger system of automated software validation.\nConsidering that every function is tested for spelling and reference, for number of arguments, for return type, and various other checks by the compiler, I think it is fair to say that the number of verifications performed by the compiler exceeds those performed by your unit-tests.\nThe Implication On Your Daily Process Test-Driven-Development is meant to teach you to architect your code in such a way that makes it easy to test. First you write a failing test, then you make that test pass. The first step, according to TDD, is to have a failing test that looks something like this:\nFirst Failing Test? But I see this as the first failing test:\nFirst Failing Test This seems like a dumb distinction to make, but I believe it to be important. If you change the type of input or the number of arguments for the convertStringToInt function, your tests don\u0026rsquo;t fail; the compilation fails before your tests can even run. Which means the input-type and input-amount test is performed automatically, but that it is still a verification step that fails properly.\nThe Implications On Your Architecture Not everyone uses TDD, but everyone should architect their Android projects in such a way that it is easy to unit-test. By going down this route you will hopefully start to implement some of the popular and sensible choices:\nModularization Inversion of Control via Dependency Injection Decoupling Classes / Dependencies Functional Reactive Programming Pretty much everything written in Refactoring by Fowler And various other small techniques that you develop subconsciously as you prioritise around testability.\nHowever, what if you prioritise your architecture to go beyond failing fast in unit tests? What if you prioritise things to fail fast like in the 4-layered test-pyramid above? Breaking changes should ideally fail at compile-time. For me, as an Android Developer, this is the ideal. My compile-time is often around a full minute and I\u0026rsquo;d prefer if breaking changes alerted me before I even have to do a full compile, much less run tests.\nA simple example would be if my convertStringToInt function required an additional argument. I\u0026rsquo;d get this error:\nPerfect test: it failed before it even ran If you want to pick up breaking changes faster, your goal is to structure your code in a way where breaking changes more often cause compile time errors before they cause test failures.\n\u0026ldquo;Okay, cool. Compilation errors are sometimes better than test failures. So give me some practical examples\u0026rdquo; This was the theoretical portion. In the follow-ups to this post, I\u0026rsquo;ll give some practical examples, which may include: This was the theoretical portion. In the follow-ups to this post, I\u0026rsquo;ll give some practical examples, which may include:\nUsing named arguments //TODO: Using custom lint-tests //TODO: Using when with enums/sealed classes //TODO: \u0026lt;reified Type\u0026gt; Generics instead of \u0026lt;*\u0026gt; //TODO: Labels for this and scope //TODO: Using libraries that generate interfaces (View Binding, NavigationSafeArgs, Dagger, Apollo) //TODO: Using coroutines for asynchronous operations //TODO: Using Kotlin Gradle DSL //TODO: Adding static analysis tools, like Detekt ","date":"2020-10-07T02:48:01+02:00","image":"https://jacquessmuts.github.io/images/compile_test1.png","permalink":"https://jacquessmuts.github.io/post/compile_time_tests/","title":"The Testing Pyramid Has a Deeper Foundation"},{"content":"This post contains further reading for my recent talk on the Slippery Slope of Unethical Programming\nAdditional Reading Some things that may be relevant or interesting for further reading on this topic. I\u0026rsquo;d love to hear more recommendations if you have any. I am no expert and my talk came mostly from a place of personal experience.\nDo artifacts have politics\nMargaret Hamilton on Software Professionalization\nThe Most Important Word Silicon Valley Doesn\u0026rsquo;t Know\nWhy the web is Communist\nBreaking up the Internet\nBreaking up app stores\nGames as a Service is Fraud\nOrganisations worth looking into or joining There are many many many organisations and it\u0026rsquo;s difficult to find comparative information or to know which ones to recommend for whome. These ones LOOK nice but my first-hand experience is extremely limited. This is part of the problem and I would love any further input on this topic.\nSouth Africa The ITA\nThe ICTU\nThe IEEE ZA\nGlobal Algorithmic Justice League\nAssociation of Computing Machinery\nGame Workers Unite\nIEEE Computer Society\nThe IET\nIndustrial Workers of the World\nPivot for Humanity\nTech Workers Coalition\nMore here\n","date":"2020-09-06T19:51:12+02:00","image":"https://jacquessmuts.github.io/images/ethicc.png","permalink":"https://jacquessmuts.github.io/post/ethicc_references/","title":"Further Reading for Ethical Programming"},{"content":"You can use a drawable to easily differentiate between flavors and variants. This will show you how.\nWhy? Ever wanted to have different icons for each flavor and variant in your Android app? Something like a little bug to indicate the debug version of your app, like so:\nSure, but it\u0026rsquo;s effort. And you have to ask a designer to make a bunch of different icons. Or, even worse, you have to create a bunch of different icons yourself. That\u0026rsquo;s wasteful, so instead you should use a layer-list. It has a default icon, and then it can dynamically insert an overlay image on top of your launcher icon, based upon your flavor or build variant. That way, you don\u0026rsquo;t need a bunch of different icons.\nHow? Assuming you have mipmap/ic_launcher icon already, you should\n1.) Create an ic_launcher_overlaid.xml file in your main/drawable folder, with the following content:\nHow does this work? The layer-list puts the launcher_overlay on top of the normal ic_launcher image, then puts 100px padding to the top and left, so that the launcher_overlay sits in the bottom right corner. That might take some adjustment to get things right.\ndrawable/ic_launcher. 2.) update your AndroidManifest.xml file to point to the new launcher icon.\nThe only thing left is:\n3.) Create drawable/launcher_overlay for each variant/flavor you need.\nYou can create a single transparent pixel in main/drawable as the default. Then add the appropriate images you need in the flavorVariant/drawable folders. I added this image to my debug folder:\nBeetle If all goes well, you\u0026rsquo;ll end up with a launcher icon that looks like this:\nIf you\u0026rsquo;re wondering about Adaptive Icons, all you have to know is that the adaptive icon references a foreground drawable. In the same way that you can replace the ic_launcher with a layer-list, you can also replace ic_launcher_foreground with a layer-list.\nI\u0026rsquo;d like to thank my colleague, Laurie Scheepers, for suggesting we try xml drawables as app icons.\n","date":"2020-02-16T14:54:38+02:00","image":"https://jacquessmuts.github.io/images/layerlist3.png","permalink":"https://jacquessmuts.github.io/post/layer_list_as_launcher_icon/","title":"Add Overlays to Your Launcher Icon Using Layer-List"},{"content":"The Kproperty class is powerful and useful.\nAccessing a property, normally You have a class, maybe a data class to retain info about films. Our class might look like this:\nfun main (args: Array\u0026lt;String\u0026gt;) {\r//sampleStart\rdata class Film(val name: String, val releaseDate: Long, val runtime: Int)\rval hereditary = Film(\u0026#34;Hereditary\u0026#34;, 1528401600, 127)\rprintln(hereditary.name)\r//sampleEnd\rprintln(\u0026#34;is the best horror film since The Thing\u0026#34;)\r}\rWhich is fine for a basic class. However there are a massive amount of different films. And different film types, with different attributes. Horror films have some sort of monster or threat, but drama films don\u0026rsquo;t. Animated films have an animation style, and documentary films have an educational subject matter. A simple solution would be to extend your Film class to have multiple nullable fields to reflect all of the potential properties of a film. That solution would reflect a database table more accurately and can be a perfectly fine solution.\nDynamic Typing via Interfaces But perhaps you have a constraint where a better approach would be to follow the SOLID principles and create some sort of Clean Code implementation of interfaces that a data class can extend. A bunch of little interfaces, like so:\n//sampleStart\rinterface Film {\rval name: String\rval releaseDate: Long\rval runtime: Int\r}\rinterface PostApocalyptic: Film {\rval yearsInFuture: Int\rval causeOfSocietalCollapse: String\r}\rinterface Romance: Film {\rval loveTriangles: Int\rval happyEnding: Boolean\r}\rdata class YoungAdultFilm(override val name: String,\roverride val releaseDate: Long,\roverride val runtime: Int,\roverride val yearsInFuture: Int,\roverride val causeOfSocietalCollapse: String,\roverride val loveTriangles: Int,\roverride val happyEnding: Boolean\r): Film, PostApocalyptic, Romance\r//sampleEnd\rfun main (args: Array\u0026lt;String\u0026gt;) {\rval divergent = YoungAdultFilm(\u0026#34;Divergent\u0026#34;, 1395172800, 127, 50, \u0026#34;fascism\u0026#34;, 1, true)\rprintln(divergent.name)\rprintln(\u0026#34;is not.\u0026#34;)\r}\rYes, this is a fairly unusual way of doing it, but sometimes it is required due to circumstances outside of your control. Luckily it still has some advantages in type safety. For example, now we are able to do checks to determine whether or not a given class is a certain type and return the property of our choosing. With the magic of Kotlin\u0026rsquo;s aggressive type inference, this code compiles and is typesafe:\ninterface Film {\rval name: String\rval releaseDate: Long\rval runtime: Int\r}\rinterface PostApocalyptic: Film {\rval yearsInFuture: Int\rval causeOfSocietalCollapse: String\r}\rinterface Romance: Film {\rval loveTriangles: Int\rval happyEnding: Boolean\r}\rdata class YoungAdultFilm(override val name: String,\roverride val releaseDate: Long,\roverride val runtime: Int,\roverride val yearsInFuture: Int,\roverride val causeOfSocietalCollapse: String,\roverride val loveTriangles: Int,\roverride val happyEnding: Boolean\r): Film, PostApocalyptic, Romance\rfun main (args: Array\u0026lt;String\u0026gt;) {\rval midsommar = YoungAdultFilm(\u0026#34;Midsommar\u0026#34;, 1395172800, 127, 0, \u0026#34;Society\u0026#34;, 1, true)\rval hasLoveTriangles = hasLoveTriangles(midsommar)\rprintln(\u0026#34;${midsommar.name} has love triangles? $hasLoveTriangles\u0026#34;)\r}\r//sampleStart\rfun hasLoveTriangles(film: Film): Boolean {\rreturn if (film is Romance) {\rfilm.loveTriangles \u0026gt; 0\r} else {\rfalse\r}\r}\r//sampleEnd\rThe film might or might not be a Romance. But the moment we have done a check for film is Romance then the compiler can infer that the film has the loveTriangles property.\nPretty convenient right?\nBut now for every single property we have to write this out manually. If film is PostApocalyptic, then get the causeOfSocietalCollapse property. If the film is Romance, then get the happyEnding property. And so forth for every single property of every interface which extends Film.\nThis all becomes rather tedious. So maybe we should rather write out something Generic, which allows us to check for any arbitrary property. Is this even possible?\nGenerics Saves the Day Again Yes. We can iterate through the properties and find the one which matches a name we specify. This is not an ideal solution because we have to pass in a string. Not very typesafe. And if any variable name changes, that string will no longer match.\nHowever, with Kotlin\u0026rsquo;s inline and reified keywords, we can do amazing generic work. First you have to have the Kotlin Reflection Library, (as described in my previous article on Reflection).\nThen you have to read about Reflection and KProperty\u0026lt;\u0026gt; and that if you can get access to a property, you can obtain the value of that property by using kproperty.get(instance).\nThen putting all that together then we can write out a fairly simple generic function, like so:\nimport kotlin.reflect.KProperty1\rinterface Film {\rval name: String\rval releaseDate: Long\rval runtime: Int\r}\rinterface PostApocalyptic: Film {\rval yearsInFuture: Int\rval causeOfSocietalCollapse: String\r}\rinterface Romance: Film {\rval loveTriangles: Int\rval happyEnding: Boolean\r}\rdata class YoungAdultFilm(override val name: String,\roverride val releaseDate: Long,\roverride val runtime: Int,\roverride val yearsInFuture: Int,\roverride val causeOfSocietalCollapse: String,\roverride val loveTriangles: Int,\roverride val happyEnding: Boolean\r): Film, PostApocalyptic, Romance\r//sampleStart\rfun main (args: Array\u0026lt;String\u0026gt;) {\rval film = YoungAdultFilm(\u0026#34;The End of Evangelion\u0026#34;, 869342400, 85, 20, \u0026#34;Instrumentality\u0026#34;, 1, true)\r[mark]val hasHappyEnding: Boolean? = getAttribute(film, Romance::happyEnding)[/mark]\rprintln(\u0026#34;${film.name} has a happy ending? $hasHappyEnding\u0026#34;)\r}\rinline fun \u0026lt;T, reified Interface\u0026gt; getAttribute(input: Film, property: KProperty1\u0026lt;Interface, T\u0026gt;): T? {\rif (input is Interface) {\rreturn property.get(input) as? T\r}\rreturn null\r}\r//sampleEnd\rNow you can just pass in your Interface::Property reference and you\u0026rsquo;ll know that the right property type will be accessed, that the property is definitely linked to the right interface, and that any future name changes will not result in breaking changes without the IDE telling you.\nTo explain the function: KProperty1 takes as Generic input the interface or class to which it belongs, as well as the required output (T). In our case we allow any output, but it must be a property of the given \u0026lt;Interface\u0026gt;. In short, we can theoretically get any attribute from a given class with casting, but that isn\u0026rsquo;t safe. Instead we use this function, and with the \u0026lt;Interface, T\u0026gt; we pass in, it is still typesafe and reliable.\nThis looks pretty great so far. If you want to keep going you can turn the getAttribute into an Extension Function or infix function on the Film class. Maybe you find this to be a bit more readable:\nimport kotlin.reflect.KProperty1\rinterface Film {\rval name: String\rval releaseDate: Long\rval runtime: Int\r}\rinterface PostApocalyptic: Film {\rval yearsInFuture: Int\rval causeOfSocietalCollapse: String\r}\rinterface Romance: Film {\rval loveTriangles: Int\rval happyEnding: Boolean\r}\rdata class YoungAdultFilm(override val name: String,\roverride val releaseDate: Long,\roverride val runtime: Int,\roverride val yearsInFuture: Int,\roverride val causeOfSocietalCollapse: String,\roverride val loveTriangles: Int,\roverride val happyEnding: Boolean\r): Film, PostApocalyptic, Romance\rfun main (args: Array\u0026lt;String\u0026gt;) {\rval film = YoungAdultFilm(\u0026#34;The End of Evangelion\u0026#34;, 869342400, 85, 20, \u0026#34;Instrumentality\u0026#34;, 1, true)\r//sampleStart\rval hasHappyEnding = film.getAttribute(Romance::happyEnding) ?: false\r//sampleEnd\rprintln(\u0026#34;${film.name} has a happy ending? $hasHappyEnding\u0026#34;)\r}\rinline fun \u0026lt;T, reified Interface\u0026gt;Film.getAttribute(property: KProperty1\u0026lt;Interface, T\u0026gt;): T? {\rreturn getFilmAttribute(this, property)\r}\rinline fun \u0026lt;T, reified Interface\u0026gt; getFilmAttribute(input: Film, property: KProperty1\u0026lt;Interface, T\u0026gt;): T? {\rif (input is Interface) {\rreturn property.get(input) as? T\r}\rreturn null\r}\rWin win? Well mostly. The disadvantage is that you can\u0026rsquo;t know whether or not any given property is nullable or not. Via this method, everything becomes nullable. To obtain only non-nullable values you have to either do the type-casting manually, or use a default value. You can see me passing false into the elvis operator above as a default value.\nFurthermore, there\u0026rsquo;s a performance cost.\nReflection is Slower, But By How Much? Luckily this one is fairly simple to test. I just access the property several times, and log how long it takes to do that directly or via reflection. The code is here, and you can run it to see the result for yourself:\nimport kotlin.reflect.KProperty1\rimport kotlin.system.measureTimeMillis\rinterface Film {\rval name: String\rval releaseDate: Long\rval runtime: Int\r}\rinterface PostApocalyptic: Film {\rval yearsInFuture: Int\rval causeOfSocietalCollapse: String\r}\rinterface Romance: Film {\rval loveTriangles: Int\rval happyEnding: Boolean\r}\rdata class YoungAdultFilm(override val name: String,\roverride val releaseDate: Long,\roverride val runtime: Int,\roverride val yearsInFuture: Int,\roverride val causeOfSocietalCollapse: String,\roverride val loveTriangles: Int,\roverride val happyEnding: Boolean\r): Film, PostApocalyptic, Romance\r//sampleStart\rval iterations = 1000000000\rfun main (args: Array\u0026lt;String\u0026gt;) {\rval normalTime = measureTimeMillis(::normalDirectAccessTime)\rprintln(\u0026#34;It takes $normalTime milliseconds to do $iterations direct property access operations\u0026#34;)\rval manualCastingTime = measureTimeMillis(::manualCastingAccessTime)\rprintln(\u0026#34;It takes $manualCastingTime milliseconds to do $iterations manual casting property access operations\u0026#34;)\rval reflectionTime = measureTimeMillis(::reflectionAccessTime)\rprintln(\u0026#34;It takes $reflectionTime milliseconds to do $iterations reflected property access operations\u0026#34;)\r}\r//sampleEnd\rfun normalDirectAccessTime() {\rval film = YoungAdultFilm(\u0026#34;The End of Evangelion\u0026#34;, 869342400, 85, 20, \u0026#34;Instrumentality\u0026#34;, 1, true)\rrepeat(iterations) {\rfilm.happyEnding\r}\r}\rfun manualCastingAccessTime() {\rval film = YoungAdultFilm(\u0026#34;The End of Evangelion\u0026#34;, 869342400, 85, 20, \u0026#34;Instrumentality\u0026#34;, 1, true)\rrepeat(iterations) {\rgetHappyEnding(film)\r}\r}\rfun getHappyEnding(film: Film): Boolean {\rreturn if (film is Romance) {\rfilm.happyEnding\r} else {\rfalse\r}\r}\rfun reflectionAccessTime() {\rval film = YoungAdultFilm(\u0026#34;The End of Evangelion\u0026#34;, 869342400, 85, 20, \u0026#34;Instrumentality\u0026#34;, 1, true)\rrepeat(iterations) {\rgetAttribute(film, Romance::happyEnding) ?: false\r}\r}\rinline fun \u0026lt;T, reified Interface\u0026gt; getAttribute(input: Film, property: KProperty1\u0026lt;Interface, *\u0026gt;): T? {\rif (input is Interface) {\rreturn property.get(input) as? T\r}\rreturn null\r}\rIn my case, the reflected property access operation takes on average about 2.5 times longer than the direct access. And the manual casting takes just a smidgeon longer than the normal direct access.\nThat\u0026rsquo;s actually pretty impressive. I was expecting more than 90% decrease in performance for reflection; instead it\u0026rsquo;s only about 60%. This is not ideal if you care about optimizing for billions of operations per second, but acceptable for less intense usecases, such as in user(Android) applications that cater for a single user at a time.\nConclusion KProperty is an essential class for doing higher-order programming in Kotlin. You can use it to get further information about any given property, or you can use it to obtain properties that you don\u0026rsquo;t normally have access to, as demonstrated above.\n","date":"2019-08-01T20:29:26+02:00","image":"https://jacquessmuts.github.io/images/generic_interfaces3.png","permalink":"https://jacquessmuts.github.io/post/kproperty/","title":"Getting arbitrary properties from unknown classes with KProperty"},{"content":"A video presentation on coroutines, a talk I gave at GDG Cape Town\n","date":"2019-07-17T21:53:05+02:00","image":"https://jacquessmuts.github.io/images/coroutines_video1.png","permalink":"https://jacquessmuts.github.io/post/coroutines_presentation/","title":"Coroutines Introduction Video"},{"content":"Working with coroutines is subtly different from normal locking functions. Introduce some thread-safety with mutex.\nThread-Safety, normally So hopefully you\u0026rsquo;re aware of basic thread-safety in Kotlin/Java. Sometimes you have a shared state of some kind that should only be accessed by one thread at a time. If you\u0026rsquo;re coming from Java, you probably use the synchronized(lock) operator in order to ensure that a shared mutable object can only be accessed one at a time. For some great reading on this topic I suggest this post on Medium.\nSo imagine a scenario where we are running a few long-running operations (like API calls), but we want to make sure that we never run more than one such operation at a time. When I was starting out with Java threading I\u0026rsquo;d probably write something risky like this:\nimport kotlinx.coroutines.GlobalScope\rimport kotlinx.coroutines.launch\rfun main() {\rval lockClass = SyncLockClass()\rfor (i in 1..10) {\rGlobalScope.launch { lockClass.runFunction(i) }\r}\rThread.sleep(2000) // We\u0026#39;re sleeping here because otherwise the JVM would terminate before printing the results\r}\rclass SyncLockClass() {\rval lock = Any()\rvar latestValue: Int = 0\r//sampleStart\rfun runFunction(input: Int) {\rprintln(\u0026#34;start function $input\u0026#34;)\r[mark]synchronized(lock) {[/mark]\rThread.sleep(100) // This could also be a long-running calculation or an API call\rlatestValue = input\r}\rprintln(\u0026#34;finished function $input at ${System.currentTimeMillis()}\u0026#34;)\r}\r//sampleEnd\rcompanion object {\r// Put the sync lock inside a companion object if you want to ensure that all instances of this class share a lock\r// val lock = Any()\r}\r}\rPress the play button above (assuming you didn\u0026rsquo;t block JavaScript on this page) to see the result. Each function is blocked and waits at the synchronized keyword for the previous function to finish. This mostly satisfies our initial requirement, but blocks any thread which hits the synchronized section while it is locked. Notice how once the first few functions are hit, the JVM is blocked from starting new threads until the previous thread finishes. In other words this method works (but is dangerous) if you have lots of threads and are running blocking functions. In Kotlin Coroutines however we run suspending functions, not blocking functions.\nBadly, with Coroutines If you\u0026rsquo;re already using coroutines you should know that a suspending function does not always block a thread. In some circumstances it pauses (suspends) the operation so that other operations can use the CPU.\nIn the example above, I\u0026rsquo;m using coroutines to launch the function, but I\u0026rsquo;m still blocking the thread every time the runFunction() function is performed, which means I\u0026rsquo;m not really utilizing the full power of Kotlin coroutines. So, what if we replaced the blocking Sleep function with the suspending delay() function?\nimport kotlinx.coroutines.GlobalScope\rimport kotlinx.coroutines.launch\rimport kotlinx.coroutines.delay\rfun main() {\rval lockClass = SyncLockClass()\rfor (i in 1..10) {\rGlobalScope.launch { lockClass.runFunction(i) }\r}\rThread.sleep(2000) // We\u0026#39;re sleeping here because otherwise the JVM would terminate before printing the results\r}\rclass SyncLockClass() {\rval lock = Any()\rvar latestValue: Int = 0\r//sampleStart\rsuspend fun runFunction(input: Int) {\rprintln(\u0026#34;start function $input\u0026#34;)\rsynchronized(lock) {\r[mark]delay(100)[/mark] // This could also be a long-running calculation or an API call\rlatestValue = input\r}\rprintln(\u0026#34;finished function $input at ${System.currentTimeMillis()}\u0026#34;)\r}\r//sampleEnd\r}\rTry to run the above code and you\u0026rsquo;ll get an error: The 'delay' suspension point is inside a critical section. What does this mean? You should not delay or suspend or sleep your thread inside of a synchronized() block, as explained somewhat in this StackOverflow Thread. It would ideally display as a warning in my first example as well. A critical section of code (such as in between the synchronized block) should be as short as possible. It is not for long-running operations because it blocks the thread. But a suspending function does not necessarily block the thread.\nSo how do we solve this issue? Maybe you\u0026rsquo;re an oldschool Java dev and you think to just use ReentrantLock() instead. After all, synchronized is merely a simplified version of ReentrantLock. This is cheating to try and be smarter than the compiler. Don\u0026rsquo;t do this. Run the code below to see why.\nimport kotlinx.coroutines.GlobalScope\rimport kotlinx.coroutines.launch\rimport kotlinx.coroutines.delay\rimport java.util.concurrent.locks.ReentrantLock\rfun main() {\rval lockClass = SyncLockClass()\rfor (i in 1..10) {\rGlobalScope.launch { lockClass.runFunction(i) }\r}\rThread.sleep(2000) // We\u0026#39;re sleeping here because otherwise the JVM would terminate before printing the results\r}\rclass SyncLockClass() {\rval reentrantLock = ReentrantLock()\rvar latestValue: Int = 0\r//sampleStart\rsuspend fun runFunction(input: Int) {\rprintln(\u0026#34;start function $input\u0026#34;)\rreentrantLock.lock()\r[mark]delay(100)[/mark] // This could also be a long-running calculation or an API call\rlatestValue = input\rreentrantLock.unlock()\rprintln(\u0026#34;finished function $input at ${System.currentTimeMillis()}\u0026#34;)\r}\r//sampleEnd\r}\rAs you can see this is not the results we want at all. The lock breaks, and then it gets ignored. You\u0026rsquo;ll probably have a runtime error in the log as well. So how do we fix this? We use a Mutex.\nCoroutines.Sync.Mutex There are some things we can read online on Mutex. We\u0026rsquo;ve got the class documentation, we have this nice acricte which explains how to use the mutex with a shared mutable state, and finally we have the official kotlin guide. That last link is probably the best one.\nThe important takeaway is that the Mutex is part of the Coroutines package, which means we know that this mutex takes the suspending nature of coroutines into account. So how would we use it in our example?\nimport kotlinx.coroutines.GlobalScope\rimport kotlinx.coroutines.launch\rimport kotlinx.coroutines.delay\rimport kotlinx.coroutines.sync.Mutex\rimport kotlinx.coroutines.sync.withLock\rfun main() {\rval lockClass = SyncLockClass()\rfor (i in 1..10) {\rGlobalScope.launch { lockClass.runSuspendFunctionWithMutex(i) }\r}\rThread.sleep(2000) // We\u0026#39;re sleeping here because otherwise the JVM would terminate before printing the results\r}\rclass SyncLockClass() {\rvar latestValue: Int = 0\rval mutex = Mutex()\r//sampleStart\rsuspend fun runSuspendFunctionWithMutex(input: Int) {\rprintln(\u0026#34;running suspend function $input\u0026#34;)\r[mark]mutex.withLock { [/mark]\rdelay(100) // This could also be a long-running calculation or an API call\rprintln(\u0026#34;finished suspend function $input at ${System.currentTimeMillis()}\u0026#34;)\rlatestValue = input\r}\r}\r//sampleEnd\r}\rAnd now things are working fine. All of the API calls are started as soon as possible and none of the threads are locked. If you look at the timestamps of the logs above you\u0026rsquo;ll see that the events are also returned with the expected 100ms delay in between each one. The only way to have achieved this result using the same techniques as in the first example is to have 10 threads at your disposal. In fact, I can probably increase the amount of coroutines I launch with this method. Let\u0026rsquo;s push it until we break it:\nimport kotlinx.coroutines.GlobalScope\rimport kotlinx.coroutines.launch\rimport kotlinx.coroutines.delay\rimport kotlinx.coroutines.sync.Mutex\rimport kotlinx.coroutines.sync.withLock\rfun main() {\rval lockClass = SyncLockClass()\rprintln(\u0026#34;(only printing the first 3, and multiples of 50)\u0026#34;)\r//sampleStart\rfor (i in 1..4000) {\rGlobalScope.launch { lockClass.runSuspendFunctionWithMutex(i) }\r}\rThread.sleep(8000) // We\u0026#39;re sleeping here because otherwise the JVM would terminate before printing the results\r//sampleEnd\r}\rclass SyncLockClass() {\rvar latestValue: Int = 0\rval mutex = Mutex()\rsuspend fun runSuspendFunctionWithMutex(input: Int) {\rif (input \u0026lt; 4 || input % 50 == 0)\rprintln(\u0026#34;running suspend function $input\u0026#34;)\rmutex.withLock {\rdelay(2) // This could also be a long-running calculation or an API call\rif (input \u0026lt; 4 || input % 50 == 0)\rprintln(\u0026#34;finished suspend function $input at ${System.currentTimeMillis()}\u0026#34;)\rlatestValue = input\r}\r}\r}\rI didn\u0026rsquo;t manage to break the Kotlin Playground with any amount of coroutines. The environment provided by the Kotlin playground only allows you to run for 10 seconds. The above code maximises that time without breaking anything, or blocking any threads. If you scroll through the logs you\u0026rsquo;ll see that some of the old functions are eventually getting finished while more coroutines are still being launched. This just goes to show how powerful coroutines and suspending functions are.\nA Better way? Threading and concurrency is a difficult topic. It is exceptionally easy to shoot yourself in the foot, by for example creating a deadlock. I suggest you read this great article by Roman Elizarov on how to avoid deadlocks in practical coroutines. (Thanks to Johannes Jensen for the suggestion.)\nOur code sample above works, but it\u0026rsquo;s still dangerous. If one function gets locked or indefinitely suspended for any reason, you end up in a deadlock. Ideally you want to avoid launching a coroutine or entering a suspend function until the conditions are ideal to do so. If you cannot stop a coroutine from being launched when it\u0026rsquo;s not ready, you can at least queue up several suspend functions using the Mutex class.\nBut since we\u0026rsquo;re queuing things up, maybe it would be better to use something like the BlockingQueue class in Java? I\u0026rsquo;m still investigating that part, but spoilers: Channels\nConclusion Coroutines are better than multithreading, but comes with all of the same dangers as normal multithreading. Just because it\u0026rsquo;s easy to use does not mean it\u0026rsquo;s safe. Be careful out there.\nCan you think of a better way to handle this scenario? Please let me know in the comments below.\n","date":"2019-06-02T09:08:10+02:00","image":"https://jacquessmuts.github.io/images/coroutine_sync_mutex.png","permalink":"https://jacquessmuts.github.io/post/coroutine_sync_mutex/","title":"Using the synchronized keyword in coroutines?"},{"content":"Callback hell happens all the time in Android. Luckily, with coroutines, there\u0026rsquo;s an easy way out.\nSo you\u0026rsquo;re hopefully aware of callback hell, which makes your code difficult to read, and also makes the sequence of events difficult to understand. This is something we want to avoid, but it\u0026rsquo;s not always easy. If you\u0026rsquo;re using any sort of third-party library, (like Firebase) you\u0026rsquo;re probably forced into this pattern regularly. A simple callback would look like this:\nAs you can see, we\u0026rsquo;re one level into callbacks. At a glance, it would seem like the result would be handled immediately after sending out the saveUsername function. But it in fact creates an asynchronous task (most likely on the IO thread). Which means the order of events quickly becomes unclear, especially to a new developer climbing on the project. An experienced dev would know that the order of events isn\u0026rsquo;t clear, but it\u0026rsquo;ll take a few minutes to fully comprehend what the actual order is.\nHowever, if your operation is suitable for coroutines (such as API calls, disk writes or background processes) we can \u0026ldquo;flatten\u0026rdquo; the callback hell fairly easily.\nSuspendCoroutine I\u0026rsquo;m assuming you\u0026rsquo;re aware of coroutines and suspendFunctions already. If not, it\u0026rsquo;s time to start using them. First, I need to introduce suspendCoroutine. The official documentation on suspendCoroutine doesn\u0026rsquo;t make it particularly clear. But this StackOverflow answer provides a good idea of how to use it. So if we were to write a suspendCoroutine version of our function, it would look like this:\nAs you can see, the saveUsername function has turned into a function which returns the result in the same line, but can only be called from a coroutineContext/suspendFunction. This is perfect for making your code look cleaner and run in sequence with more confidence.\nHowever, it requires you to write a suspendCoroutine function for each function you want to flatten in this way. This adds a lot of boilerplate. So is there some way we can use generics to avoid this boilerplate? Of course!\nGeneric SuspendCoroutine If you read my first article on kotlin generics you\u0026rsquo;ll know that the IntelliJ IDE is smarter than us, so we\u0026rsquo;ll use it to generate our function. We\u0026rsquo;ll call our function suspendAsync() and pass in our method, along with the input, and see what happens. Remember you can pass a method reference with instance::method\nIf you see this warning, you\u0026#39;re headed in the right direction. Then IntelliJ creates a function which looks like this:\nNot generic yet. And through a little bit of Generic reworking, as well as my knowledge of KFunction analogues, I replaced the \u0026lt;String\u0026gt; input and output types with generic types, resulting in this function:\nAs you can see, it\u0026rsquo;s about the same as our previous function. The difference is, you can pass in any function which takes a single input and a function callback, and it becomes a one-liner instead of a callback.\nIf you want to pass in two inputs, it\u0026rsquo;s slightly trickier, but still very doable:\nAnd there you have it. You can reduce any qualifying callback with these functions. Other variations can be covered with a few more generic functions. However, it doesn\u0026rsquo;t feel very nice calling a function in this way. First you write suspendAsync, then you pass in the function you actually want to call? Not the best, because we\u0026rsquo;re used to referencing the function we want to call first.\nSo maybe we can do better?\nGeneric Infix SuspendCoroutine Extension Function I like the infix notation in Kotlin, though I usually avoid it because it\u0026rsquo;s a little dangerous and it\u0026rsquo;s not easy for new developers to discover it\u0026rsquo;s usage in any given codebase. In this case the increased readability and ease of use may be worth it.\nSo using the same method of letting the IDE generate our function for us, we write out the infix function we want. I call it suspendAndInvokeWith, because we are invoking a function, turning it into a suspend function, and passing in arguments.\nIf it wasn\u0026#39;t for compiler suggestions I\u0026#39;d be useless. Which we clean up and genericify a little bit into our result:\nThis feels a lot more natural. You start out by writing the function you would normally write, using the infix notation and passing in your input.\nInfix functions require only a single input, so if you want to pass in more than one argument into a function, you need to do it by using Pairs or Triples, like so:\nAnd there you have it. This won\u0026rsquo;t work on everything, but it\u0026rsquo;s a start to reducing boilerplate.\nSource At Flat Circle, we\u0026rsquo;re trying to make our code as readable as possible, and found that using coroutines and avoiding callback hell is a good way to go about doing this. So we built these infix notations (and a few other utility functions) into a little CoroutineHelper Library to make our lives easier. Please go ahead and use that library or copy the code to help make your code as readable as possible.\nConclusion Callback hell isn\u0026rsquo;t the end of the world, but sometimes it can add just a little bit too much confusion to an already complex lifecycle. Hopefully with Coroutines, coupled with the techniques and Generic Utility functions above, you can reduce callback hell a little bit in your code.\n","date":"2019-05-20T23:12:36+02:00","image":"https://jacquessmuts.github.io/images/callback_hell4.png","permalink":"https://jacquessmuts.github.io/post/callback-hell/","title":"Escaping Callback Hell with Generic SuspendCoroutine Infix Extension Functions"},{"content":"KFunction can be written in more than one way. Here\u0026rsquo;s a list of analogues, plus some criticism of the Receiver Function.\nAfter my previous article on Reflection was posted, I got a great comment from @pacoworks:\nKSuspendFunction does not support that syntax (yet?). So to build up towards understanding KSuspendFunction1, I stuck with KFunction1 and its usage.\nNormally I use your syntax, but the article was already too long to get into that :P pic.twitter.com/nUaDArDA5S\n\u0026mdash; Jacques Smuts (@JacquesSmuts) May 8, 2019 I assumed that since the IDE told me that there was a type mismatch, that suspend functions weren\u0026rsquo;t supported.\nTurns out I was wrong; KSuspendFunction can be shortened. (click that thread to read more) They\u0026rsquo;re called Receiver Functions and they have since been added to the Kotlin official documentation for higher-order-functions with a nice explanation.\nSo, in order to help me remember the different ways to reference higher-order functions, I made this grid. It omits the list of passed interfaces for brevity.\nKFunction Analogue ReceiverFunction KFunction1\u0026lt;Interface, Result\u0026gt; (Interface) -\u0026gt; Result Interface.() -\u0026gt; Result KFunction2\u0026lt;Interface, Input, Result\u0026gt; (Interface, Input) -\u0026gt; Result Interface.(Input) -\u0026gt; Result KFunction3\u0026lt;Interface, In1, In2, Result\u0026gt; (Interface, In1, In2) -\u0026gt; Result Interface.(In1, In2) -\u0026gt; Result KSuspendFunction1\u0026lt;Interface, Result\u0026gt; suspend (Interface) -\u0026gt; Result suspend Interface.() -\u0026gt; Result KSuspendFunction2\u0026lt;Interface, Input, Result\u0026gt; suspend (Interface, Input) -\u0026gt; Result suspend Interface.(Input) -\u0026gt; Result In all 3 cases you have to add implementation \u0026quot;org.jetbrains.kotlin:kotlin-reflect:$kotlinVersion\u0026quot; in your gradle.\nHowever you only have to add the import kotlin.reflect.KFunction1 import at the top of your file if you\u0026rsquo;re using the explicit KFunction syntax.\nI like the way ReceiverFunction is composed and I would like to use that, however I see a problem with it. If any new developer unused to this syntax works on this code, what should they google to find out more? ().-\u0026gt;T ? It\u0026rsquo;s difficult to work with Reflection and Generics the first time, but if you see \u0026ldquo;KSuspendFunction1\u0026rdquo; you will be able to google it and find references to Reflection to understand what the code is doing.\nThe other thing to note is that if you use the ReceiverFunction notation and pass the wrong type of function, the IDE will always default to referring to the passed function argument as \u0026ldquo;KFunction\u0026rdquo;.\nI didn\u0026#39;t call it a KSuspendFunction, but the IDE does. Which means the developer is likely to think that they are passing something entirely different than the required input, unless they know both the KFunction notation and the Receiver Function notation.\nSince I like the Receiver Function syntax, I\u0026rsquo;m going to add a link to the Kotlin documentation in my code comments wherever I use the ReceiverFunction syntax. This explanation on StackOverflow as well, since it explains the usage of receiver functions a bit better.\nConclusion Receiver Functions are nice, but there is no simple way for a developer to get to the right documentation from the code or IDE unless they already know what Receiver Functions are, or that they refer to KFunction. In order to make it easier for people to understand your code, you need to choose one:\nRefer to KFunction explicitly; or Add comments every time you use Higher Order Receiver Functions ","date":"2019-05-08T17:54:58+02:00","image":"https://jacquessmuts.github.io/images/generic_interfaces3.png","permalink":"https://jacquessmuts.github.io/post/kfunction_analogues/","title":"The Problem with Kotlin Kfunction Receiver Functions"},{"content":"This is the template I use to create new Android libraries with CircleCI support for Continuous Deployment.\nLibraries: Better Than Util Classes I often find myself copying code from other projects. After some discussion with my colleagues we decided to put everything that we re-use into libraries. Even those tiny util functions you usually just copy-paste when you need it. Libraries are better than copy-pasting for several reasons:\nIt makes future work easier Writing a library teaches you to think more abstractly about any problem you\u0026rsquo;re trying to solve. Future work can benefit everyone, rather than just the project you\u0026rsquo;re on It forces separation of concerns Plus many more reasons, but you probably know this already. So here\u0026rsquo;s the steps I follow to create a library:\nHow to Make a Library 1. Create a LibraryNameExample project in Android Studio and add a LibraryName module. I followed this guide for the first part, but I don\u0026rsquo;t deploy on JitPack. I prefer Bintray for having easier deployment to JCenter(). Being on JCenter gives your library a false sense of official status, which you want.\n2. Add the project to GitHub under LibraryName 3. Create the repo on Bintray under LibraryName 4. Add the bintray-release dependency and settings I followed this guide, and created my account on bintray as instructed there. However I save my BINTRAY_KEY api key in my CircleCI setup, and access it from the gradle setup for bintray-release, like so:\n5. Add the project to CircleCI For my CircleCI config.yml file, I literally just copy-paste the same file across all my library projects for the initial setup. This file doesn\u0026rsquo;t run tests or anything right now, but as I\u0026rsquo;m building up my libraries that will change. If it has changed to add features you\u0026rsquo;re not using, this is the link to the original file at the time of writing.\nAlso remember to add the environment variable BINTRAY_KEY to your CircleCI settings, like so:\nUse your own Bintray API key, from Bintray User settings. You may also want to set up CircleCI to build only on pull requests. But don\u0026rsquo;t worry, this config won\u0026rsquo;t deploy without your say-so.\n6. Deploy! Commit to master and make sure CircleCI builds your project. If you copied my CircleCI config file, you should see a workflow that looks like this:\nHodl Click the \u0026ldquo;Hold\u0026rdquo; button and approve the build. If you do, it will deploy to Bintray. If you get any errors, CircleCI should have logs which explain the issue so you can resolve it from there.\n7. Add The Repo to JCenter() Once you have a package deployed to Bintray, click the \u0026ldquo;Link to JCenter()\u0026rdquo; button on the package details view on Bintray. It\u0026rsquo;s slightly hidden but it\u0026rsquo;s there somewhere. After a few hours, you should have an approved JCenter() link. You only have to do this once, because every future deployment of this repo will be deployed to JCenter automatically.\n8. Update the Readme with Status Badges Create a Readme.md in your repo which explains how to use and download your repo. You\u0026rsquo;ll find the gradle instructions on Bintray, as well as a Status Badge you can paste into your Readme. It will look like this:\nand it will update automatically every time you deploy a new version, without needing to update your readme. I usually add a status badge for CircleCI as well.\n9. Share It Congrats, you just deployed your library. Share it with the world. Tweet about it, blog about it, even just share in the comments below. Libraries are amazing.\nExamples Some libraries I\u0026rsquo;ve made using this method:\nRxHelpers ConnectivityHelper ViewHelper CoroutineHelper LiveDataHelper ","date":"2019-05-07T22:19:00+02:00","image":"https://jacquessmuts.github.io/images/library_template3.png","permalink":"https://jacquessmuts.github.io/post/library_template/","title":"Creating and Deploying an Android Library via CircleCI"},{"content":"With Kotlin, it\u0026rsquo;s easier than ever to code with reflection and generics. This post attempts to give one example.\nBackground: An unlikely scenario I couldn\u0026rsquo;t think of a simpler scenario to demonstrate KFunction and KSuspendFunction working well in tandem with Generics, so please bear with me when I present this unlikely scenario.\nLet\u0026rsquo;s assume you have several different endpoints and you need to differentiate between them easily, even though they can change dynamically. If you\u0026rsquo;re an Android developer, you\u0026rsquo;re probably used to Retrofit and its associated Interfaces. You have several classes that look like this:\nEach of these interfaces are used by RetroFit to generate the right api call you can call. And then you have a few classes which may or may not implement these interfaces. So if you have a list of unknown services and you want to get the AWS Repos, you have to iterate through your services, find the AwsService and then make the call. You can do something like this:\nBut this means that every single time you want to check your GitHubRepos, your AwsRepos, or any other api call, you have to manually write out this entire process from scratch. That\u0026rsquo;s highly inefficient and boilerplatey. Can\u0026rsquo;t you push them all through some central function?\nYes, with Reflection + Generics you can\nKotlin Reflection So first, you should read the official kotlin documentation on reflection. It\u0026rsquo;s a really good starting point, even if you already know Reflection from other languages. Even better, read this great guide on Medium about both reflection and generics. But how does this relate to us?\nWe want to pass the AWS Repo function in the AWS interface and get the AWSRepo result. Later we\u0026rsquo;ll make it generic, but first step is just reflection. So let\u0026rsquo;s call that non-existent function. We\u0026rsquo;ll call it doAwsApiCall and it has two input parameters:\nThe list of services; and the listAwsRepos method from the AwsCodeCommitService interface. doAwsApiCall(services, AwsCodeCommitService::listAwsRepos) But that function doesn\u0026rsquo;t exist yet, so just ask IntelliJ/Android Studio to create it for you. (We\u0026rsquo;re doing this because the IDE is smarter than us at figuring out the input parameters.)\nIf you see this warning, you\u0026#39;re headed in the right direction. And you\u0026rsquo;ll get something like this:\nSo the KFunction1 here is reference to a specific function that can be called. To make a class run that function, you just have to pass the calling class into the function. Yes, that\u0026rsquo;s hard to understand and a little bit backwards, but maybe it makes more sense in code.\nThis is almost the same as our first implementation, except for the commented part. What this means is that we can pass in any function from the AwsCodeCommitService interface, and it will automatically be called inside the doAwsApiCall function.\nBut this means we have to write this code for each of our interfaces. One for GitHubService, one for BitBucketService, and so forth. That\u0026rsquo;s a lot better, but still not good enough. If we wanta single function to handle all of these api calls, then we must answer this question:\nCan we write a function that takes ANY interface and call ANY function from that interface, and return ANY result, and still be type safe? Yes, with Reflection and Generics you can!\nKotlin Generics Plus Reflection So, using the great explanation into inline functions and reified Generics in this great guide on Medium as a basis, I\u0026rsquo;m going to just turn everything into a Generic and see what happens.\nAll I did was\nAdded \u0026lt;reified Service, Result\u0026gt; to the beginning of the function, to pass in those types Replace any reference to AwsCodeCommitService with the generic Service Replaced any reference to List\u0026lt;AwsRepo\u0026gt; with the generic Result And it works and accepts literally any interface::method pair which returns the expected Result type. I wanted to restrict it a bit, so I made sure that Service extends the RetroService interface I defined all the way at the top. Now it only accepts the right methods.\nHowever\u0026hellip;\nIf you see this warning, you\u0026#39;re headed in the right direction. The GitHubRepos api call takes a username as an input parameter. So now the IDE is telling you that listGitHubRepos(username) is a KFunction2. What\u0026rsquo;s that?\nKFunction1 is a function reference with zero input arguments, e.g. listAwsRepos() KFunction2 is a function reference with one input argument, e.g. listGitHubRepos(username: String) So let\u0026rsquo;s create another doApiCall(), except that it takes kFunction2 as an input.\nAnd this function works. All we had to do was add the Input Type as a Generic type, and pass the input into the KFunction2. This means in other words that we can pass in a list of unknown classes, a function and an input. If any class in that list of unknown classes is the correct type, the right function will be called on that class.\nThe best part is that because of Kotlin\u0026rsquo;s intensely awesome type inference, I never even had to pass in the \u0026lt;Service, Input, Result\u0026gt; types. It was inferred automatically.\nSuspend Functions You may have noticed that little suspend function back in the beginning. I didn\u0026rsquo;t forget about it. It\u0026rsquo;s handled identically, but you have to create a new function for it unfortunately. Something like this:\nAs you can see, all I did was replace KFunction1 and KFunction2 with KSuspendFunction1 and KSuspendFunction2, respectively. The reason for this is because the signature for a suspend function and normal function in Kotlin are not the same. Hopefully if you\u0026rsquo;re using suspend functions you already know this though.\nConclusion I don\u0026rsquo;t even know why anyone would land in this bizarre scenario of needing to iterate through dozens of dynamically changing classes with unpredictable interfaces. But if you do, it\u0026rsquo;s very solveable with the techniques above.\nReflection is great Generics are amazing Kotlin Generics + Reflection + Type Inference is mindblowing If you can get your mind around higher-order functions, generics, and reflection, you will become way more efficient as a developer. I hope this shows an example why.\nFollow-Up and Thanks I wrote a follow-up article based on some nice feedback I got.\nI\u0026rsquo;d also like to thank my colleague, Jannie at Flat Circle for coming up with this problem for me to solve.\n","date":"2019-05-01T08:30:00+02:00","image":"https://jacquessmuts.github.io/images/generic_interfaces3.png","permalink":"https://jacquessmuts.github.io/post/generic_interface_and_methods/","title":"Generics + Reflection + Type Inference + Reified Type = Kotlin Magic"},{"content":"If you\u0026rsquo;re thinking of modularizing your Android App and you use Android Room, you should not pass around your Room Entity.\nRoom: Only In Your Database Module Room is great, and so is modularization. If you\u0026rsquo;re using Room, you probably have several Room Entity Objects that look kinda like this:\nChances are you\u0026rsquo;re passing this model around everywhere. Every time you want to access your User class, or save it, or display the data to the UI, you use the same User class, which doubles as your Room Entity.\nFor a one-module proof of concept app, this is probably fine. But the moment your app expands and you begin to modularize, you\u0026rsquo;ll run into issues. Specifically, Gradle will tell you that you have unresolved Supertypes.\nSupertypes of the following classes cannot be resolved. Please make sure you have the required dependencies in the classpath: com.example.persistence.AppDatabase, unresolved supertypes: androidx.room.RoomDatabase This happens because you\u0026rsquo;re passing the Entity from your database module to other modules which don\u0026rsquo;t implement the room compiler. So then you add the room compiler to your other modules. Just like StackOverflow suggests.\nDon\u0026rsquo;t do this. Please. It breaks the core concept of Information Hiding as would be required by a project that implements a proper Separation of Concerns.\nMap Your Entity Instead, you should have two distinct objects. You should one object that represents the database Entity, and one object for passing around the pure data. Your database module should be literally the only module which imports the Room library. If any other module imports those implementation details of the database module, then you are not Information Hiding as you should. This is especially true if you may want to change out your Room database for something like SqlDelight.\nInstead, map your data class to a new Entity, like so:\nPerhaps you have some other way of mapping to and from your User to your UserEntity class. You may think it\u0026rsquo;d be better if it happened automatically via a Serializer or the like. Normally I\u0026rsquo;d agree that automated serialization is easier in the long term, but this way, any changes to your User class results in a compiler error in your UserEntity class, which shows you:\nThat your database needs to go up a version; and what migration steps to take, based on what changes the mapper requires. I suggest you turn all your database classes into internal class, as I\u0026rsquo;ve discussed before. This is a bit of a tedious thing to do sometimes, but you will be super-happy in the long term. Future work and refactoring will be very easy.\nThere is one other thing though.\nLiveData + Room, But In Another Module One of the nice things about LiveData and Room is how easily they interact.\nBut then you have this problem in your Repository\nIf you see this warning, you\u0026#39;re headed in the right direction. Turns out you can\u0026rsquo;t use LiveData to hook directly on to your database, because that exposes internal database entities outside the module. You want LiveData but you still want a proper separation of concerns. How? You use the LiveData Transformation function.\nThis means you have a direct LiveData pipeline from your ViewModel/View to your database, without actually exposing your internal database components. You get to have your module and access it too.\nConclusion I showed you why you shouldn\u0026rsquo;t pass around your Room @Entity, and how to separate your modules without losing functionality.\n","date":"2019-04-25T10:35:54+02:00","image":"https://jacquessmuts.github.io/images/modularization_room1.png","permalink":"https://jacquessmuts.github.io/post/modularization_room/","title":"Don't Pass Around Your Room/Database Entity"},{"content":"You should modularize your Kotlin Android app, since it\u0026rsquo;s the best way to enforce separation of concerns, but how do you know if you\u0026rsquo;re doing it right? Here\u0026rsquo;s some tips to help.\nAm I doing it right? If you\u0026rsquo;re following one of the great guides out there, you\u0026rsquo;re probably doing it mostly right, but how do you know? Can you measure a difference? Here\u0026rsquo;s a good way to check. Generate a dependency graph for your app. I used APK Dependency Graph Generator. All you need to do is compile the apk-dependency project, point it to an apk, and it will generate an interactive graph like the one below.\nIf you click the link below, you should see something like this. This graph demonstrates a way to look for ease of refactoring with two nice examples:\nThe ServerClient in the bottom right provides a complete separation between the api and the rest of the app. The api calls can therefore be refactored easily. Lots of classes are reliant on the TeaBag class in the middle. A single change there is likely to cascade outward, making refactoring difficult. Below, an example of a project which is not easy to refactor, update or even debug:\nAn unnamed legacy project. There is no separation of concerns here. This project is in dire need of modularization, but where do you even begin?\nWhere to begin? I usually follow these steps:\nCreate a module Identify one or more classes that should not be accessible outside of a specific context Move those classes into the module Add the internal visibility modifier (or making the class package-private if you\u0026rsquo;re using Java) Try to compile and get an error Fix this error without removing the internal keyword. This may involve creating a little bit of boilerplate. If you see this warning, you\u0026#39;re headed in the right direction. A specific example of this would be the database module. I moved my database class, data model classes, DAO classes, and repository class into the database module. I made everything internal except for repository, which provides the API to the database for the rest of the app. After some restructuring and cleanup, I ended up with a nicer class structure.\nDependency graph, but after internalizing the database moduleIt seems similar to the one above, but with some subtle differences.\nOkay, I have to admit, it doesn\u0026rsquo;t seem like we made that much of a difference. But here\u0026rsquo;s the real benefit:\nThe real benefit When a new developer works in a non-database module and tries to access the database directly, the compiler will stop them.\nThe two dependency graphs are similar, except that a moment\u0026rsquo;s thoughtlessness can pull everything into spaghetti in the first instance. I have used the internal modifier in my database module, which means that a developer would be stopped from breaking a delicate separation of concerns with a single function.\nTrying to access the database directly from MainActivity.kt. If you run into these errors in a project, you know the project is well modularized.\nConclusion We have looked at two ways in which to analyze the state of your modularization:\nAPK Dependency Graph Generator; and The prevalance of the internal modifier (or lack of public in Java) ","date":"2019-04-20T21:15:17+02:00","image":"https://jacquessmuts.github.io/images/modularization3.png","permalink":"https://jacquessmuts.github.io/post/modularization/","title":"Is your modularization making any progress?"},{"content":"This details how I made this static github page.\nFirst, I installed Hugo on my local machine and created a site. I chose the theme Hugo-Nuo because it looked nice and because the author has a github page with regular updates and decent documentation.\nIt was not crashing, so I deployed it to a Github static page using the official Hugo Guide for hosting on Github.\nThen I wrote this blog post using the standard template by running hugo new post/how_i_made_this.md and writing the rest in the resulting .md file. I ran deploy.sh (from the Hugo Guide\u0026rsquo;s instructions) and did not see this post.\nSo I removed the \u0026ldquo;draft:true\u0026rdquo; property from this post, felt like an idiot for taking 30min to figure that out, then deployed again.\nFinally, I realized I had forgotten to set the new domain in my config file after deploying. So I fixed that and now everything seems to be working, I think.\nNick Rout noticed that the quote styling didn\u0026rsquo;t come out right, so I changed that. It also screwed up my normal code highlighting, but I think it\u0026rsquo;s better to use GitHub gists anyway, and I\u0026rsquo;m too lazy to create my own custom code styling template and shortcode in hugo. I\u0026rsquo;ve had some issues with the code highlighting\u0026rsquo;s limited support for Kotlin so I\u0026rsquo;m basically just pretending it doesn\u0026rsquo;t exist.\nNick also noticed that the images stretch badly on mobile. This was because I was setting a constant height to my images, and the width expanded only up until it hit the edge. So I changed all my images to use width=percentage% and now the scaling is right.\nFor SEO purposes, I also added my site to GoogleAnalytics Console, and registered my site with Google Search Console to claim ownership of the domain according to google. I should now get pushed up on Google Search results a bit, and also get analytics on how many people visit my site or click through based on search terms, if I understand correctly.\nI added the Kotlin Playgrounds shortcode as well, in order to make my kotlin more interactive\nI\u0026rsquo;m putting further tests in here. For example:\nCode Highlighting 1 2 3 4 5 6 7 8 9 10 inline fun\u0026lt;reified T: Any\u0026gt; get(key: String): T? { val instance = FirebaseRemoteConfig.getInstance() return when (T::class) { Long::class -\u0026gt; instance.getLong(key) as T? String::class -\u0026gt; instance.getString(key) as T? else -\u0026gt; throw IllegalArgumentException(\u0026#34;the ${T::class} class is not supported yet\u0026#34;) } } Which you\u0026rsquo;ll notice is incorrectly styled with red thanks to the single-quote styling change I made.\nGit Gist Image with zooming and title Obviously, this is my face. Click to zoom. Embedded Youtube Linking to another post References\n","date":"2019-04-20T10:43:30+02:00","image":"https://jacquessmuts.github.io/images/how_i_made_this1.png","permalink":"https://jacquessmuts.github.io/post/how_i_made_this/","title":"How I Made This Website"},{"content":"My original site is at JacquesSmuts.com\nThere isn\u0026rsquo;t a lot there. Since it\u0026rsquo;s WordPress, I\u0026rsquo;ll probably take it down some time and move everything to this site.\nIf I\u0026rsquo;m feeling less lazy, I\u0026rsquo;ll probably host this static page there, or just set jacquessmuts.com to redirect here.\n","date":"2019-04-18T17:03:47+02:00","permalink":"https://jacquessmuts.github.io/post/original-site/","title":"Original Site"}]